---
title: "Database Schema"
description: "Complete SQLite database schema with Prisma ORM implementation"
weight: 10
layout: "docs"
---

# Database Schema

AI Code Terminal uses SQLite with Prisma ORM for lightweight, efficient data storage. The schema is designed for single-tenant operation with minimal data requirements while maintaining security and performance.

## Database Technology Stack

### Core Components

- **Database Engine:** SQLite 3.x
- **ORM:** Prisma 6.x
- **Query Builder:** Prisma Client
- **Migrations:** Prisma Migrate
- **Schema Definition:** Prisma Schema Language

### Advantages of SQLite + Prisma

- **Zero Configuration:** No database server setup required
- **ACID Compliance:** Full transaction support
- **Cross-platform:** Works on all operating systems
- **Embedded:** No network overhead
- **Type Safety:** Prisma generates TypeScript types
- **Migration System:** Version-controlled schema changes

## Complete Schema Definition

### Actual Prisma Schema File

**Location:** `/prisma/schema.prisma`

```prisma
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// Single-user system: minimal global settings
model Settings {
  id                    String    @id @default("singleton")
  githubToken           String?   // Encrypted GitHub OAuth access token
  githubRefreshToken    String?   // Encrypted GitHub OAuth refresh token
  githubTokenExpiresAt  DateTime? // The expiration date of the current access token
  theme                 String?   // Theme preference JSON
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@map("settings")
}

model Workspace {
  id            String   @id @default(cuid())
  name          String
  githubRepo    String   @unique // Format: "owner/repo" - unique across system
  githubUrl     String   // Full GitHub repository URL
  localPath     String   // Local filesystem path
  isActive      Boolean  @default(true)
  lastSyncAt    DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  sessions      Session[]

  @@map("workspaces")
}

model Session {
  id               String    @id @default(cuid())
  shellPid         Int?      // Process ID of the shell session
  socketId         String?   // Current Socket.IO connection ID
  status           String    @default("active") // active, paused, terminated
  lastActivityAt   DateTime  @default(now())
  createdAt        DateTime  @default(now())
  endedAt          DateTime?

  // Foreign keys
  workspaceId      String?
  workspace        Workspace? @relation(fields: [workspaceId], references: [id], onDelete: SetNull)

  @@map("sessions")
}
```

## Data Models Deep Dive

### Settings Model

The Settings model implements a singleton pattern for single-tenant configuration:

```typescript
// TypeScript interface (generated by Prisma)
interface Settings {
  id: string;                    // Always "singleton"
  githubToken: string | null;    // Encrypted GitHub OAuth access token
  githubRefreshToken: string | null; // Encrypted GitHub OAuth refresh token
  githubTokenExpiresAt: Date | null; // Token expiration timestamp
  theme: string | null;          // Theme preference JSON
  createdAt: Date;
  updatedAt: Date;
}
```

**Usage Examples:**

```typescript
// Get current settings
const settings = await prisma.settings.findUnique({
  where: { id: 'singleton' }
});

// Update GitHub token
await prisma.settings.upsert({
  where: { id: 'singleton' },
  update: {
    githubToken: encryptedToken,
    githubRefreshToken: encryptedRefreshToken,
    githubTokenExpiresAt: expiryDate
  },
  create: {
    id: 'singleton',
    githubToken: encryptedToken,
    githubRefreshToken: encryptedRefreshToken,
    githubTokenExpiresAt: expiryDate
  }
});
```

### Workspace Model

Represents individual repository workspaces:

```typescript
interface Workspace {
  id: string;              // CUID identifier
  name: string;            // Workspace name
  githubRepo: string;      // "owner/repository" (unique)
  githubUrl: string;       // Full GitHub URL
  localPath: string;       // Filesystem path
  isActive: boolean;       // Active status
  lastSyncAt: Date | null; // Last Git sync timestamp
  createdAt: Date;
  updatedAt: Date;
  sessions: Session[];     // Related terminal sessions
}
```

**Usage Examples:**

```typescript
// Create new workspace
const workspace = await prisma.workspace.create({
  data: {
    name: 'my-react-app',
    githubRepo: 'octocat/my-react-app',
    githubUrl: 'https://github.com/octocat/my-react-app',
    localPath: '/app/workspaces/my-react-app'
  }
});

// Get workspace with sessions
const workspaceWithSessions = await prisma.workspace.findUnique({
  where: { id: 'workspace_id' },
  include: {
    sessions: {
      where: { status: 'active' }
    }
  }
});

// Update last sync time
await prisma.workspace.update({
  where: { id: 'workspace_id' },
  data: { lastSyncAt: new Date() }
});
```

### Session Model

Terminal session tracking:

```typescript
interface Session {
  id: string;                    // CUID identifier
  shellPid: number | null;       // Process ID of the shell session
  socketId: string | null;       // Socket.IO connection ID
  status: string;                // active, paused, terminated
  lastActivityAt: Date;          // Last activity timestamp
  createdAt: Date;
  endedAt: Date | null;          // Session end time
  workspaceId: string | null;    // Associated workspace
  workspace: Workspace | null;   // Workspace relation
}
```

**Usage Examples:**

```typescript
// Create new session
const session = await prisma.session.create({
  data: {
    socketId: socket.id,
    workspaceId: workspace.id
  }
});

// Update session activity
await prisma.session.update({
  where: { id: session.id },
  data: { lastActivityAt: new Date() }
});

// Terminate session
await prisma.session.update({
  where: { id: session.id },
  data: {
    status: 'terminated',
    endedAt: new Date()
  }
});

// Clean up old sessions
await prisma.session.deleteMany({
  where: {
    status: 'terminated',
    endedAt: {
      lt: new Date(Date.now() - 24 * 60 * 60 * 1000) // 24 hours ago
    }
  }
});
```

## Database Operations

### Prisma Client Setup

```typescript
// prisma/client.ts
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient({
  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
});

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
}

// Graceful shutdown
process.on('beforeExit', async () => {
  await prisma.$disconnect();
});
```

### Common Query Patterns

#### Single-Tenant Settings Management

```typescript
// Settings service (actual implementation)
export class SettingsService {
  private static readonly SETTINGS_ID = 'singleton';

  static async getSettings() {
    return await prisma.settings.findUnique({
      where: { id: this.SETTINGS_ID }
    });
  }

  static async updateSettings(data: Partial<Settings>) {
    return await prisma.settings.upsert({
      where: { id: this.SETTINGS_ID },
      update: data,
      create: { id: this.SETTINGS_ID, ...data }
    });
  }

  static async updateTheme(theme: string) {
    return await this.updateSettings({ theme });
  }

  static async getGitHubToken() {
    const settings = await this.getSettings();
    if (!settings?.githubToken) {
      throw new Error('GitHub token not found');
    }
    
    // Decrypt token using AES-256-CBC
    return decrypt(settings.githubToken);
  }
}
```

#### Workspace Management

```typescript
export class WorkspaceService {
  static async createWorkspace(githubRepo: string, githubUrl: string) {
    return await prisma.workspace.create({
      data: {
        name: githubRepo.split('/')[1], // Extract repo name
        githubRepo,
        githubUrl,
        localPath: `/app/workspaces/${githubRepo.split('/')[1]}`
      }
    });
  }

  static async getActiveWorkspaces() {
    return await prisma.workspace.findMany({
      where: { isActive: true },
      include: {
        sessions: {
          where: { status: 'active' }
        }
      },
      orderBy: { updatedAt: 'desc' }
    });
  }

  static async syncWorkspace(workspaceId: string) {
    return await prisma.workspace.update({
      where: { id: workspaceId },
      data: { lastSyncAt: new Date() }
    });
  }

  static async deleteWorkspace(workspaceId: string) {
    // Sessions are set to null on workspace delete (SetNull cascade)
    return await prisma.workspace.delete({
      where: { id: workspaceId }
    });
  }
}
```

#### Session Management

```typescript
export class SessionService {
  static async createSession(workspaceId: string, socketId: string) {
    return await prisma.session.create({
      data: {
        workspaceId,
        socketId
      }
    });
  }

  static async getActiveSessions() {
    return await prisma.session.findMany({
      where: { status: 'active' },
      include: { workspace: true }
    });
  }

  static async terminateSession(sessionId: string) {
    return await prisma.session.update({
      where: { id: sessionId },
      data: {
        status: 'terminated',
        endedAt: new Date()
      }
    });
  }

  static async cleanupOldSessions(olderThanHours: number = 24) {
    const cutoff = new Date(Date.now() - olderThanHours * 60 * 60 * 1000);
    
    return await prisma.session.deleteMany({
      where: {
        OR: [
          { status: 'terminated', endedAt: { lt: cutoff } },
          { status: 'active', lastActivityAt: { lt: cutoff } }
        ]
      }
    });
  }
}
```

## Database Migrations

### Migration System

Prisma Migrate handles schema changes:

```bash
# Generate migration
npx prisma migrate dev --name add_github_id_to_workspace

# Apply migrations to production
npx prisma migrate deploy

# Reset database (development only)
npx prisma migrate reset
```

### Migration History

Track all schema changes:

```bash
# View migration status
npx prisma migrate status

# View migration history
ls prisma/migrations/
```

### Example Migration

```sql
-- CreateTable
CREATE TABLE "workspaces" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "name" TEXT NOT NULL,
    "githubRepo" TEXT NOT NULL,
    "githubUrl" TEXT NOT NULL,
    "githubId" INTEGER,
    "localPath" TEXT NOT NULL,
    "branch" TEXT NOT NULL DEFAULT 'main',
    "description" TEXT,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "lastSyncAt" DATETIME,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL
);

-- CreateIndex
CREATE UNIQUE INDEX "workspaces_name_key" ON "workspaces"("name");
CREATE UNIQUE INDEX "workspaces_githubRepo_key" ON "workspaces"("githubRepo");
```

## Performance Optimization

### Indexing Strategy

```sql
-- Automatic indexes on unique fields
CREATE UNIQUE INDEX "workspaces_githubRepo_key" ON "workspaces"("githubRepo");

-- Implicit indexes on foreign keys and frequently queried fields
-- SQLite automatically creates indexes on PRIMARY KEY and UNIQUE constraints
-- Additional indexes created as needed for performance optimization
```

### Query Optimization

```typescript
// Efficient workspace queries
const workspacesWithActiveSessions = await prisma.workspace.findMany({
  where: { isActive: true },
  select: {
    id: true,
    name: true,
    githubRepo: true,
    lastSyncAt: true,
    _count: {
      select: {
        sessions: {
          where: { status: 'active' }
        }
      }
    }
  }
});

// Simple pagination for workspaces
const getWorkspacesPaginated = async (page: number = 1, limit: number = 10) => {
  const skip = (page - 1) * limit;
  
  const [workspaces, total] = await Promise.all([
    prisma.workspace.findMany({
      skip,
      take: limit,
      orderBy: { updatedAt: 'desc' },
      include: {
        sessions: {
          where: { status: 'active' }
        }
      }
    }),
    prisma.workspace.count({ where: { isActive: true } })
  ]);
  
  return { workspaces, total, pages: Math.ceil(total / limit) };
};
```

## Data Integrity and Validation

### Schema Constraints

```prisma
model Workspace {
  // Unique constraints
  githubRepo  String @unique  // "owner/repo" must be unique
  
  // Required fields
  name        String
  localPath   String
  githubUrl   String
  
  // Default values
  isActive    Boolean @default(true)
  
  // Timestamps (automatically managed)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}
```

### Application-Level Validation

```typescript
// Validation middleware used in the actual implementation
const validateWorkspaceCreation = (req, res, next) => {
  const { githubRepo, githubUrl } = req.body;

  if (!githubRepo || !githubUrl) {
    return res.status(400).json({
      error: 'Invalid parameters',
      message: 'githubRepo and githubUrl are required'
    });
  }

  // Validate GitHub repository format (owner/repo)
  if (!githubRepo.match(/^[\w\-\.]+\/[\w\-\.]+$/)) {
    return res.status(400).json({
      error: 'Invalid repository format',
      message: 'Repository must be in format: owner/repo'
    });
  }

  next();
};

// Session status validation
const validateSessionUpdate = (status) => {
  const validStatuses = ['active', 'paused', 'terminated'];
  return validStatuses.includes(status);
};

// Usage in controllers (simplified validation)
export const createWorkspace = async (req, res) => {
  try {
    const { githubRepo, githubUrl } = req.body;
    const workspace = await WorkspaceService.createWorkspace(githubRepo, githubUrl);
    res.status(201).json({
      success: true,
      workspace,
      message: 'Workspace created successfully'
    });
  } catch (error) {
    res.status(500).json({
      error: 'Failed to create workspace',
      message: error.message
    });
  }
};
```

## Backup and Recovery

### Database Backup Strategy

```bash
#!/bin/bash
# backup-database.sh

DATABASE_PATH="./data/database.db"
BACKUP_DIR="./backups"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)

# Create backup directory
mkdir -p $BACKUP_DIR

# Create backup with timestamp
cp $DATABASE_PATH $BACKUP_DIR/database_backup_$TIMESTAMP.db

# Compress backup
gzip $BACKUP_DIR/database_backup_$TIMESTAMP.db

# Keep only last 7 backups
ls -t $BACKUP_DIR/database_backup_*.db.gz | tail -n +8 | xargs -r rm

echo "Database backup completed: database_backup_$TIMESTAMP.db.gz"
```

### Automated Backup with Node.js

```typescript
import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';
import cron from 'node-cron';

class DatabaseBackup {
  private backupDir = path.join(process.cwd(), 'backups');
  private dbPath = process.env.DATABASE_URL?.replace('file:', '') || './data/database.db';

  constructor() {
    // Ensure backup directory exists
    if (!fs.existsSync(this.backupDir)) {
      fs.mkdirSync(this.backupDir, { recursive: true });
    }
  }

  async createBackup(): Promise<string> {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupPath = path.join(this.backupDir, `database_backup_${timestamp}.db`);
    
    // Copy database file
    fs.copyFileSync(this.dbPath, backupPath);
    
    // Compress backup
    execSync(`gzip "${backupPath}"`);
    
    // Cleanup old backups (keep last 30)
    this.cleanupOldBackups();
    
    return `${backupPath}.gz`;
  }

  private cleanupOldBackups(): void {
    const backupFiles = fs.readdirSync(this.backupDir)
      .filter(file => file.startsWith('database_backup_') && file.endsWith('.gz'))
      .sort()
      .reverse();
    
    // Remove all but the most recent 30 backups
    backupFiles.slice(30).forEach(file => {
      fs.unlinkSync(path.join(this.backupDir, file));
    });
  }

  startAutomatedBackups(): void {
    // Daily backup at 2 AM
    cron.schedule('0 2 * * *', async () => {
      try {
        const backupFile = await this.createBackup();
        console.log(`Automated backup created: ${backupFile}`);
      } catch (error) {
        console.error('Automated backup failed:', error);
      }
    });
  }
}

// Initialize automated backups
const backup = new DatabaseBackup();
backup.startAutomatedBackups();
```

## Monitoring and Maintenance

### Database Health Checks

```typescript
export class DatabaseHealth {
  static async checkHealth(): Promise<HealthStatus> {
    try {
      // Test connection
      await prisma.$queryRaw`SELECT 1`;
      
      // Get database size
      const dbStats = await this.getDatabaseStats();
      
      // Check for locked tables
      const lockedTables = await this.checkForLocks();
      
      return {
        status: 'healthy',
        size: dbStats.size,
        tables: dbStats.tableCount,
        connections: dbStats.connections,
        locks: lockedTables
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        error: error.message
      };
    }
  }

  private static async getDatabaseStats() {
    const tables = await prisma.$queryRaw<Array<{ name: string, count: number }>>`
      SELECT name, COUNT(*) as count 
      FROM sqlite_master 
      WHERE type='table'
    `;
    
    const dbSize = await prisma.$queryRaw<[{ size: number }]>`
      SELECT page_count * page_size as size 
      FROM pragma_page_count(), pragma_page_size()
    `;
    
    return {
      tableCount: tables.length,
      size: dbSize[0]?.size || 0,
      connections: 1 // SQLite is single-connection
    };
  }
}
```

### Maintenance Tasks

```typescript
export class DatabaseMaintenance {
  // Clean up old data
  static async runMaintenance(): Promise<void> {
    await Promise.all([
      this.cleanupOldSessions(),
      this.cleanupOldLogs(),
      this.cleanupOldMetrics(),
      this.vacuum()
    ]);
  }

  private static async cleanupOldSessions(): Promise<void> {
    const cutoff = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000); // 7 days
    
    const result = await prisma.session.deleteMany({
      where: {
        status: 'terminated',
        endedAt: { lt: cutoff }
      }
    });
    
    console.log(`Cleaned up ${result.count} old sessions`);
  }

  private static async cleanupOldLogs(): Promise<void> {
    const cutoff = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000); // 30 days
    
    const result = await prisma.authLog.deleteMany({
      where: { createdAt: { lt: cutoff } }
    });
    
    console.log(`Cleaned up ${result.count} old auth logs`);
  }

  private static async vacuum(): Promise<void> {
    await prisma.$executeRaw`VACUUM`;
    console.log('Database vacuum completed');
  }
}

// Schedule daily maintenance
cron.schedule('0 1 * * *', async () => {
  console.log('Running database maintenance...');
  await DatabaseMaintenance.runMaintenance();
  console.log('Database maintenance completed');
});
```

## Next Steps

- **[Data Models](/docs/database/models/):** Detailed model relationships and usage
- **[Development Setup](/docs/development/setup/):** Database development environment  
- **[Production Setup](/docs/deployment/production/):** Production database configuration