---
title: "Database Schema"
description: "Complete SQLite database schema with Prisma ORM implementation"
weight: 10
layout: "docs"
---

# Database Schema

AI Code Terminal uses SQLite with Prisma ORM for lightweight, efficient data storage. The schema is designed for single-tenant operation with minimal data requirements while maintaining security and performance.

## Database Technology Stack

### Core Components

- **Database Engine:** SQLite 3.x
- **ORM:** Prisma 5.x
- **Query Builder:** Prisma Client
- **Migrations:** Prisma Migrate
- **Schema Definition:** Prisma Schema Language

### Advantages of SQLite + Prisma

- **Zero Configuration:** No database server setup required
- **ACID Compliance:** Full transaction support
- **Cross-platform:** Works on all operating systems
- **Embedded:** No network overhead
- **Type Safety:** Prisma generates TypeScript types
- **Migration System:** Version-controlled schema changes

## Complete Schema Definition

### Prisma Schema File

**Location:** `/prisma/schema.prisma`

```prisma
// This is your Prisma schema file
// Learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// Single-tenant settings (singleton pattern)
model Settings {
  id                    String    @id @default("singleton")
  githubToken           String?   // Encrypted GitHub OAuth access token
  githubTokenIv         String?   // Initialization vector for token encryption
  githubRefreshToken    String?   // Encrypted GitHub OAuth refresh token  
  githubRefreshTokenIv  String?   // Initialization vector for refresh token
  githubTokenExpiresAt  DateTime? // Token expiration timestamp
  theme                 String?   // Current UI theme preference
  preferences           String?   // JSON string of user preferences
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@map("settings")
}

// Repository workspaces
model Workspace {
  id            String    @id @default(cuid())
  name          String    @unique // Workspace display name
  githubRepo    String    @unique // "owner/repo" format
  githubUrl     String    // Full GitHub repository URL
  githubId      Int?      // GitHub repository ID
  localPath     String    // Local filesystem path
  branch        String    @default("main") // Default branch
  description   String?   // Optional description
  isActive      Boolean   @default(true)
  lastSyncAt    DateTime? // Last Git sync timestamp
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  // Relations
  sessions      Session[] // Terminal sessions in this workspace
  
  @@map("workspaces")
}

// Terminal sessions
model Session {
  id               String    @id @default(cuid())
  shellPid         Int?      // Process ID of shell process
  socketId         String?   // Socket.IO connection ID
  shell            String    @default("bash") // Shell type (bash, zsh, fish)
  status           String    @default("active") // active, paused, terminated
  workingDirectory String?   // Current working directory
  environment      String?   // JSON string of environment variables
  lastActivityAt   DateTime  @default(now())
  createdAt        DateTime  @default(now())
  endedAt          DateTime? // Session termination time
  exitCode         Int?      // Shell exit code
  
  // Relations
  workspaceId      String?
  workspace        Workspace? @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  
  @@map("sessions")
}

// Authentication and usage logs
model AuthLog {
  id          String   @id @default(cuid())
  action      String   // login, logout, token_refresh, api_access
  success     Boolean
  ipAddress   String?
  userAgent   String?
  details     String?  // JSON string with additional details
  createdAt   DateTime @default(now())
  
  @@map("auth_logs")
}

// System metrics and monitoring
model SystemMetric {
  id          String   @id @default(cuid())
  metric      String   // cpu_usage, memory_usage, disk_usage, active_sessions
  value       Float    // Numeric value
  unit        String?  // percentage, bytes, count, etc.
  metadata    String?  // JSON string with additional data
  createdAt   DateTime @default(now())
  
  // Index for efficient time-series queries
  @@index([metric, createdAt])
  @@map("system_metrics")
}
```

## Data Models Deep Dive

### Settings Model

The Settings model implements a singleton pattern for single-tenant configuration:

```typescript
// TypeScript interface (generated by Prisma)
interface Settings {
  id: string;                    // Always "singleton"
  githubToken: string | null;    // Encrypted access token
  githubTokenIv: string | null;  // Encryption IV
  githubRefreshToken: string | null;
  githubRefreshTokenIv: string | null;
  githubTokenExpiresAt: Date | null;
  theme: string | null;          // "dark" | "light" | custom
  preferences: string | null;    // JSON preferences
  createdAt: Date;
  updatedAt: Date;
}
```

**Usage Examples:**

```typescript
// Get current settings
const settings = await prisma.settings.findUnique({
  where: { id: 'singleton' }
});

// Update GitHub token
await prisma.settings.upsert({
  where: { id: 'singleton' },
  update: {
    githubToken: encryptedToken,
    githubTokenIv: iv,
    githubTokenExpiresAt: expiryDate
  },
  create: {
    id: 'singleton',
    githubToken: encryptedToken,
    githubTokenIv: iv,
    githubTokenExpiresAt: expiryDate
  }
});
```

### Workspace Model

Represents individual repository workspaces:

```typescript
interface Workspace {
  id: string;              // CUID identifier
  name: string;            // Display name (unique)
  githubRepo: string;      // "owner/repository"
  githubUrl: string;       // Full GitHub URL
  githubId: number | null; // GitHub repository ID
  localPath: string;       // Filesystem path
  branch: string;          // Default branch
  description: string | null;
  isActive: boolean;
  lastSyncAt: Date | null; // Last Git operation
  createdAt: Date;
  updatedAt: Date;
  sessions: Session[];     // Related sessions
}
```

**Usage Examples:**

```typescript
// Create new workspace
const workspace = await prisma.workspace.create({
  data: {
    name: 'my-react-app',
    githubRepo: 'octocat/my-react-app',
    githubUrl: 'https://github.com/octocat/my-react-app',
    githubId: 123456,
    localPath: '/app/workspaces/my-react-app',
    branch: 'main',
    description: 'React application workspace'
  }
});

// Get workspace with sessions
const workspaceWithSessions = await prisma.workspace.findUnique({
  where: { id: 'workspace_id' },
  include: {
    sessions: {
      where: { status: 'active' }
    }
  }
});

// Update last sync time
await prisma.workspace.update({
  where: { id: 'workspace_id' },
  data: { lastSyncAt: new Date() }
});
```

### Session Model

Terminal session tracking:

```typescript
interface Session {
  id: string;                    // CUID identifier
  shellPid: number | null;       // Process ID
  socketId: string | null;       // Socket.IO connection
  shell: string;                 // Shell type
  status: string;                // Session status
  workingDirectory: string | null;
  environment: string | null;    // JSON env vars
  lastActivityAt: Date;
  createdAt: Date;
  endedAt: Date | null;
  exitCode: number | null;
  workspaceId: string | null;
  workspace: Workspace | null;
}
```

**Usage Examples:**

```typescript
// Create new session
const session = await prisma.session.create({
  data: {
    shell: 'bash',
    socketId: socket.id,
    workspaceId: workspace.id,
    workingDirectory: workspace.localPath,
    environment: JSON.stringify(process.env)
  }
});

// Update session activity
await prisma.session.update({
  where: { id: session.id },
  data: { lastActivityAt: new Date() }
});

// Terminate session
await prisma.session.update({
  where: { id: session.id },
  data: {
    status: 'terminated',
    endedAt: new Date(),
    exitCode: 0
  }
});

// Clean up old sessions
await prisma.session.deleteMany({
  where: {
    status: 'terminated',
    endedAt: {
      lt: new Date(Date.now() - 24 * 60 * 60 * 1000) // 24 hours ago
    }
  }
});
```

## Database Operations

### Prisma Client Setup

```typescript
// prisma/client.ts
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient({
  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
});

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
}

// Graceful shutdown
process.on('beforeExit', async () => {
  await prisma.$disconnect();
});
```

### Common Query Patterns

#### Single-Tenant Settings Management

```typescript
// Settings service
export class SettingsService {
  private static readonly SETTINGS_ID = 'singleton';

  static async getSettings() {
    return await prisma.settings.findUnique({
      where: { id: this.SETTINGS_ID }
    });
  }

  static async updateSettings(data: Partial<Settings>) {
    return await prisma.settings.upsert({
      where: { id: this.SETTINGS_ID },
      update: data,
      create: { id: this.SETTINGS_ID, ...data }
    });
  }

  static async updateTheme(theme: string) {
    return await this.updateSettings({ theme });
  }

  static async getGitHubToken() {
    const settings = await this.getSettings();
    if (!settings?.githubToken) {
      throw new Error('GitHub token not found');
    }
    
    // Decrypt token
    return decrypt({
      encryptedData: settings.githubToken,
      iv: settings.githubTokenIv!
    });
  }
}
```

#### Workspace Management

```typescript
export class WorkspaceService {
  static async createWorkspace(data: CreateWorkspaceData) {
    return await prisma.workspace.create({
      data: {
        ...data,
        localPath: path.join(process.env.WORKSPACE_ROOT || './workspaces', data.name)
      }
    });
  }

  static async getActiveWorkspaces() {
    return await prisma.workspace.findMany({
      where: { isActive: true },
      include: {
        sessions: {
          where: { status: 'active' }
        }
      },
      orderBy: { updatedAt: 'desc' }
    });
  }

  static async syncWorkspace(workspaceId: string) {
    return await prisma.workspace.update({
      where: { id: workspaceId },
      data: { lastSyncAt: new Date() }
    });
  }

  static async deleteWorkspace(workspaceId: string) {
    // Cascade delete will handle related sessions
    return await prisma.workspace.delete({
      where: { id: workspaceId }
    });
  }
}
```

#### Session Management

```typescript
export class SessionService {
  static async createSession(workspaceId: string, socketId: string) {
    return await prisma.session.create({
      data: {
        workspaceId,
        socketId,
        shell: 'bash'
      }
    });
  }

  static async getActiveSessions() {
    return await prisma.session.findMany({
      where: { status: 'active' },
      include: { workspace: true }
    });
  }

  static async terminateSession(sessionId: string, exitCode?: number) {
    return await prisma.session.update({
      where: { id: sessionId },
      data: {
        status: 'terminated',
        endedAt: new Date(),
        exitCode
      }
    });
  }

  static async cleanupOldSessions(olderThanHours: number = 24) {
    const cutoff = new Date(Date.now() - olderThanHours * 60 * 60 * 1000);
    
    return await prisma.session.deleteMany({
      where: {
        OR: [
          { status: 'terminated', endedAt: { lt: cutoff } },
          { status: 'active', lastActivityAt: { lt: cutoff } }
        ]
      }
    });
  }
}
```

## Database Migrations

### Migration System

Prisma Migrate handles schema changes:

```bash
# Generate migration
npx prisma migrate dev --name add_github_id_to_workspace

# Apply migrations to production
npx prisma migrate deploy

# Reset database (development only)
npx prisma migrate reset
```

### Migration History

Track all schema changes:

```bash
# View migration status
npx prisma migrate status

# View migration history
ls prisma/migrations/
```

### Example Migration

```sql
-- CreateTable
CREATE TABLE "workspaces" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "name" TEXT NOT NULL,
    "githubRepo" TEXT NOT NULL,
    "githubUrl" TEXT NOT NULL,
    "githubId" INTEGER,
    "localPath" TEXT NOT NULL,
    "branch" TEXT NOT NULL DEFAULT 'main',
    "description" TEXT,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "lastSyncAt" DATETIME,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL
);

-- CreateIndex
CREATE UNIQUE INDEX "workspaces_name_key" ON "workspaces"("name");
CREATE UNIQUE INDEX "workspaces_githubRepo_key" ON "workspaces"("githubRepo");
```

## Performance Optimization

### Indexing Strategy

```sql
-- Automatic indexes on unique fields
CREATE UNIQUE INDEX "workspaces_name_key" ON "workspaces"("name");
CREATE UNIQUE INDEX "workspaces_githubRepo_key" ON "workspaces"("githubRepo");

-- Custom indexes for common queries
CREATE INDEX "sessions_workspace_id_status_idx" ON "sessions"("workspaceId", "status");
CREATE INDEX "sessions_last_activity_idx" ON "sessions"("lastActivityAt");
CREATE INDEX "system_metrics_metric_created_idx" ON "system_metrics"("metric", "createdAt");
```

### Query Optimization

```typescript
// Efficient workspace queries
const workspacesWithActiveSessions = await prisma.workspace.findMany({
  where: { isActive: true },
  select: {
    id: true,
    name: true,
    githubRepo: true,
    lastSyncAt: true,
    _count: {
      select: {
        sessions: {
          where: { status: 'active' }
        }
      }
    }
  }
});

// Pagination for large datasets
const getWorkspacesPaginated = async (page: number, limit: number) => {
  const skip = (page - 1) * limit;
  
  const [workspaces, total] = await Promise.all([
    prisma.workspace.findMany({
      skip,
      take: limit,
      orderBy: { updatedAt: 'desc' },
      include: {
        sessions: {
          where: { status: 'active' },
          take: 1
        }
      }
    }),
    prisma.workspace.count({ where: { isActive: true } })
  ]);
  
  return { workspaces, total, pages: Math.ceil(total / limit) };
};
```

## Data Integrity and Validation

### Schema Constraints

```prisma
model Workspace {
  // Unique constraints
  name        String @unique
  githubRepo  String @unique
  
  // Required fields
  localPath   String
  githubUrl   String
  
  // Default values
  isActive    Boolean @default(true)
  branch      String  @default("main")
  
  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}
```

### Application-Level Validation

```typescript
import { z } from 'zod';

// Validation schemas
export const CreateWorkspaceSchema = z.object({
  name: z.string().min(1).max(50).regex(/^[a-zA-Z0-9-_]+$/),
  githubRepo: z.string().regex(/^[a-zA-Z0-9-_.]+\/[a-zA-Z0-9-_.]+$/),
  githubUrl: z.string().url(),
  description: z.string().max(200).optional(),
  branch: z.string().min(1).default('main')
});

export const UpdateSessionSchema = z.object({
  status: z.enum(['active', 'paused', 'terminated']),
  workingDirectory: z.string().optional(),
  lastActivityAt: z.date().default(() => new Date())
});

// Usage in API endpoints
export const createWorkspace = async (req: Request, res: Response) => {
  try {
    const validatedData = CreateWorkspaceSchema.parse(req.body);
    const workspace = await WorkspaceService.createWorkspace(validatedData);
    res.json(workspace);
  } catch (error) {
    if (error instanceof z.ZodError) {
      res.status(400).json({ error: 'Validation failed', details: error.errors });
    } else {
      res.status(500).json({ error: 'Internal server error' });
    }
  }
};
```

## Backup and Recovery

### Database Backup Strategy

```bash
#!/bin/bash
# backup-database.sh

DATABASE_PATH="./data/database.db"
BACKUP_DIR="./backups"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)

# Create backup directory
mkdir -p $BACKUP_DIR

# Create backup with timestamp
cp $DATABASE_PATH $BACKUP_DIR/database_backup_$TIMESTAMP.db

# Compress backup
gzip $BACKUP_DIR/database_backup_$TIMESTAMP.db

# Keep only last 7 backups
ls -t $BACKUP_DIR/database_backup_*.db.gz | tail -n +8 | xargs -r rm

echo "Database backup completed: database_backup_$TIMESTAMP.db.gz"
```

### Automated Backup with Node.js

```typescript
import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';
import cron from 'node-cron';

class DatabaseBackup {
  private backupDir = path.join(process.cwd(), 'backups');
  private dbPath = process.env.DATABASE_URL?.replace('file:', '') || './data/database.db';

  constructor() {
    // Ensure backup directory exists
    if (!fs.existsSync(this.backupDir)) {
      fs.mkdirSync(this.backupDir, { recursive: true });
    }
  }

  async createBackup(): Promise<string> {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupPath = path.join(this.backupDir, `database_backup_${timestamp}.db`);
    
    // Copy database file
    fs.copyFileSync(this.dbPath, backupPath);
    
    // Compress backup
    execSync(`gzip "${backupPath}"`);
    
    // Cleanup old backups (keep last 30)
    this.cleanupOldBackups();
    
    return `${backupPath}.gz`;
  }

  private cleanupOldBackups(): void {
    const backupFiles = fs.readdirSync(this.backupDir)
      .filter(file => file.startsWith('database_backup_') && file.endsWith('.gz'))
      .sort()
      .reverse();
    
    // Remove all but the most recent 30 backups
    backupFiles.slice(30).forEach(file => {
      fs.unlinkSync(path.join(this.backupDir, file));
    });
  }

  startAutomatedBackups(): void {
    // Daily backup at 2 AM
    cron.schedule('0 2 * * *', async () => {
      try {
        const backupFile = await this.createBackup();
        console.log(`Automated backup created: ${backupFile}`);
      } catch (error) {
        console.error('Automated backup failed:', error);
      }
    });
  }
}

// Initialize automated backups
const backup = new DatabaseBackup();
backup.startAutomatedBackups();
```

## Monitoring and Maintenance

### Database Health Checks

```typescript
export class DatabaseHealth {
  static async checkHealth(): Promise<HealthStatus> {
    try {
      // Test connection
      await prisma.$queryRaw`SELECT 1`;
      
      // Get database size
      const dbStats = await this.getDatabaseStats();
      
      // Check for locked tables
      const lockedTables = await this.checkForLocks();
      
      return {
        status: 'healthy',
        size: dbStats.size,
        tables: dbStats.tableCount,
        connections: dbStats.connections,
        locks: lockedTables
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        error: error.message
      };
    }
  }

  private static async getDatabaseStats() {
    const tables = await prisma.$queryRaw<Array<{ name: string, count: number }>>`
      SELECT name, COUNT(*) as count 
      FROM sqlite_master 
      WHERE type='table'
    `;
    
    const dbSize = await prisma.$queryRaw<[{ size: number }]>`
      SELECT page_count * page_size as size 
      FROM pragma_page_count(), pragma_page_size()
    `;
    
    return {
      tableCount: tables.length,
      size: dbSize[0]?.size || 0,
      connections: 1 // SQLite is single-connection
    };
  }
}
```

### Maintenance Tasks

```typescript
export class DatabaseMaintenance {
  // Clean up old data
  static async runMaintenance(): Promise<void> {
    await Promise.all([
      this.cleanupOldSessions(),
      this.cleanupOldLogs(),
      this.cleanupOldMetrics(),
      this.vacuum()
    ]);
  }

  private static async cleanupOldSessions(): Promise<void> {
    const cutoff = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000); // 7 days
    
    const result = await prisma.session.deleteMany({
      where: {
        status: 'terminated',
        endedAt: { lt: cutoff }
      }
    });
    
    console.log(`Cleaned up ${result.count} old sessions`);
  }

  private static async cleanupOldLogs(): Promise<void> {
    const cutoff = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000); // 30 days
    
    const result = await prisma.authLog.deleteMany({
      where: { createdAt: { lt: cutoff } }
    });
    
    console.log(`Cleaned up ${result.count} old auth logs`);
  }

  private static async vacuum(): Promise<void> {
    await prisma.$executeRaw`VACUUM`;
    console.log('Database vacuum completed');
  }
}

// Schedule daily maintenance
cron.schedule('0 1 * * *', async () => {
  console.log('Running database maintenance...');
  await DatabaseMaintenance.runMaintenance();
  console.log('Database maintenance completed');
});
```

## Next Steps

- **[Data Models](/docs/database/models/):** Detailed model relationships and usage
- **[Development Setup](/docs/development/setup/):** Database development environment  
- **[Production Setup](/docs/deployment/production/):** Production database configuration