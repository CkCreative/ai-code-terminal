<script>
        const { createApp } = Vue;
        
        createApp({
            data() {
                return {
                    isAuthenticated: false,
                    username: null,
                    errorMessage: null,
                    socket: null,
                    terminal: null,
                    fitAddon: null,
                    workspaces: [],
                    selectedWorkspace: null,
                    repositories: [],
                    repositoriesLoading: false,
                    repositoryError: null,
                    repositoryPage: 1,
                    repositoryHasMore: true,
                    repositoryLoadingMore: false,
                    scrollTimeout: null,
                    repositorySearchTerm: '',
                    searchTimeout: null,
                    showRepositoriesModal: false,
                    cloningRepository: null,
                    cloneProgress: null,
                    cloneError: null,
                    stats: {},
                    statsInterval: null,
                    isMobile: false,
                    sidebarOpen: false,
                    statsOpen: false,
                    showThemeModal: false,
                    currentTheme: this.getDefaultTheme(),
                    availableThemes: [],
                    showDeleteModal: false,
                    workspaceToDelete: null,
                    deleteFiles: false,
                    deletingWorkspace: false,
                    connectionError: null,
                    // File Explorer
                    fileExplorerEnabled: true,
                    fileExplorerCollapsed: false,
                    currentFiles: [],
                    currentPath: '.',
                    selectedFile: null,
                    loadingFiles: false,
                    fileError: null,
                    showHiddenFiles: false,
                    directoryCache: new Map(),
                    cacheTimeout: 5 * 60 * 1000, // 5 minutes
                    fileSearchTerm: '',
                    fileSearchTimeout: null,
                    selectedFileIndex: -1,
                    // Context Menu
                    showContextMenu: false,
                    contextMenuX: 0,
                    contextMenuY: 0,
                    contextMenuFile: null,
                    // File Preview Modal
                    showFilePreviewModal: false,
                    previewFile: null,
                    previewData: null,
                    previewLoading: false,
                    previewError: null
                };
            },
            
            async mounted() {
                // Check if mobile
                this.checkMobile();
                window.addEventListener('resize', this.checkMobile);

                // Check for authentication token in URL
                const urlParams = new URLSearchParams(window.location.search);
                const token = urlParams.get('token');
                const error = urlParams.get('error');
                
                if (error) {
                    this.errorMessage = decodeURIComponent(error);
                    window.history.replaceState({}, document.title, '/');
                    return;
                }
                
                if (token) {
                    localStorage.setItem('authToken', token);
                    window.history.replaceState({}, document.title, '/');
                }
                
                // Check existing token
                const existingToken = localStorage.getItem('authToken');
                if (existingToken) {
                    this.isAuthenticated = true;
                    await this.loadAvailableThemes();
                    this.initializeApp();
                }

                // Initialize Feather Icons
                this.$nextTick(() => {
                    feather.replace();
                });

                // Handle escape key to close modals and file navigation
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.showThemeModal = false;
                        this.showRepositoriesModal = false;
                        this.showDeleteModal = false;
                        this.showFilePreviewModal = false;
                        this.showContextMenu = false;
                    }
                    
                    // File explorer keyboard navigation
                    if (this.selectedWorkspace && !this.fileExplorerCollapsed && 
                        !this.showRepositoriesModal && !this.showThemeModal && 
                        !this.showDeleteModal && !this.showFilePreviewModal &&
                        !document.querySelector('input:focus') &&
                        !this.isTerminalFocused()) {
                        
                        this.handleFileNavigationKeys(e);
                    }
                });
            },
            
            computed: {
                filteredFiles() {
                    if (!this.fileSearchTerm || this.fileSearchTerm.trim() === '') {
                        return this.currentFiles.filter(file => 
                            this.showHiddenFiles || !file.isHidden
                        );
                    }
                    
                    const searchTerm = this.fileSearchTerm.toLowerCase().trim();
                    return this.currentFiles.filter(file => {
                        const matchesSearch = file.name.toLowerCase().includes(searchTerm);
                        const matchesHidden = this.showHiddenFiles || !file.isHidden;
                        return matchesSearch && matchesHidden;
                    });
                },

                highlightedContent() {
                    if (!this.previewData?.content || !this.previewFile) {
                        return '';
                    }

                    const language = this.getPrismLanguage(this.previewFile);
                    if (language && window.Prism && window.Prism.languages[language]) {
                        try {
                            return window.Prism.highlight(this.previewData.content, window.Prism.languages[language], language);
                        } catch (error) {
                            console.warn('Syntax highlighting failed:', error);
                            return this.escapeHtml(this.previewData.content);
                        }
                    }
                    
                    return this.escapeHtml(this.previewData.content);
                },

                pathSegments() {
                    if (!this.currentPath || this.currentPath === '.') {
                        return [];
                    }
                    return this.currentPath.split('/').filter(segment => segment.length > 0);
                }
            },
            
            methods: {
                getDefaultTheme() {
                    return {
                        name: 'VS Code Dark',
                        type: 'dark',
                        colors: {
                            primary: '#1e1e1e',
                            secondary: '#252526', 
                            tertiary: '#2d2d30',
                            sidebar: '#181818',
                            border: '#3c3c3c',
                            textPrimary: '#cccccc',
                            textSecondary: '#969696',
                            textMuted: '#6a6a6a',
                            accentBlue: '#007acc',
                            accentGreen: '#16825d',
                            accentRed: '#f14c4c',
                            terminalBg: '#1e1e1e'
                        },
                        terminal: {
                            background: '#1e1e1e',
                            foreground: '#cccccc',
                            cursor: '#cccccc',
                            selection: '#264f78',
                            black: '#000000',
                            red: '#f14c4c',
                            green: '#16825d',
                            yellow: '#ff8c00',
                            blue: '#007acc',
                            magenta: '#c678dd',
                            cyan: '#56b6c2',
                            white: '#cccccc',
                            brightBlack: '#666666',
                            brightRed: '#f14c4c',
                            brightGreen: '#16825d',
                            brightYellow: '#ff8c00',
                            brightBlue: '#007acc',
                            brightMagenta: '#c678dd',
                            brightCyan: '#56b6c2',
                            brightWhite: '#ffffff'
                        }
                    };
                },

                async loadAvailableThemes() {
                    try {
                        const response = await fetch('/api/themes', {
                            headers: {
                                'Authorization': `Bearer ${localStorage.getItem('authToken')}`
                            }
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            if (data.success && data.themes) {
                                this.availableThemes = data.themes.map(theme => ({
                                    ...theme,
                                    terminal: {
                                        background: theme.terminal.background,
                                        foreground: theme.terminal.foreground,
                                        cursor: theme.terminal.cursor,
                                        selection: theme.terminal.selection,
                                        black: theme.terminal.ansiBlack,
                                        red: theme.terminal.ansiRed,
                                        green: theme.terminal.ansiGreen,
                                        yellow: theme.terminal.ansiYellow,
                                        blue: theme.terminal.ansiBlue,
                                        magenta: theme.terminal.ansiMagenta,
                                        cyan: theme.terminal.ansiCyan,
                                        white: theme.terminal.ansiWhite,
                                        brightBlack: theme.terminal.ansiBrightBlack,
                                        brightRed: theme.terminal.ansiBrightRed,
                                        brightGreen: theme.terminal.ansiBrightGreen,
                                        brightYellow: theme.terminal.ansiBrightYellow,
                                        brightBlue: theme.terminal.ansiBrightBlue,
                                        brightMagenta: theme.terminal.ansiBrightMagenta,
                                        brightCyan: theme.terminal.ansiBrightCyan,
                                        brightWhite: theme.terminal.ansiBrightWhite
                                    }
                                }));
                            }
                        } else {
                            console.warn('Failed to load themes from server, using fallback');
                            this.availableThemes = this.getFallbackThemes();
                        }
                    } catch (error) {
                        console.error('Failed to load themes:', error);
                        this.availableThemes = this.getFallbackThemes();
                    }
                },

                getFallbackThemes() {
                    return [this.getDefaultTheme()];
                },

                checkMobile() {
                    this.isMobile = window.innerWidth <= 768;
                    if (!this.isMobile) {
                        this.sidebarOpen = false;
                        this.statsOpen = false;
                    }
                },

                toggleSidebar() {
                    this.sidebarOpen = !this.sidebarOpen;
                },

                toggleStats() {
                    this.statsOpen = !this.statsOpen;
                },


                async selectTheme(theme) {
                    this.currentTheme = theme;
                    this.showThemeModal = false;
                    this.applyTheme(theme);
                    await this.saveTheme(theme);
                    
                    // Update terminal if active
                    if (this.terminal && this.selectedWorkspace) {
                        this.setupTerminal();
                    }
                },

                applyTheme(theme) {
                    const root = document.documentElement;
                    const colors = theme.colors;
                    
                    // Background Colors
                    root.style.setProperty('--bg-primary', colors.primary);
                    root.style.setProperty('--bg-secondary', colors.secondary);
                    root.style.setProperty('--bg-tertiary', colors.tertiary);
                    root.style.setProperty('--bg-sidebar', colors.sidebar);
                    
                    // Text Colors  
                    root.style.setProperty('--text-primary', colors.textPrimary);
                    root.style.setProperty('--text-secondary', colors.textSecondary);
                    root.style.setProperty('--text-muted', colors.textMuted);
                    
                    // Border & Divider Colors
                    root.style.setProperty('--border-color', colors.border || colors.textMuted);
                    
                    // Accent Colors
                    root.style.setProperty('--accent-blue', colors.accentBlue);
                    root.style.setProperty('--accent-blue-hover', colors.accentBlueHover || colors.accentBlue);
                    root.style.setProperty('--accent-green', colors.accentGreen);
                    root.style.setProperty('--accent-green-hover', colors.accentGreenHover || colors.accentGreen);
                    root.style.setProperty('--accent-red', colors.accentRed);
                    root.style.setProperty('--accent-red-hover', colors.accentRedHover || colors.accentRed);
                    root.style.setProperty('--accent-orange', colors.accentOrange || colors.accentBlue);
                    root.style.setProperty('--accent-purple', colors.accentPurple || colors.accentBlue);
                    
                    // Component-specific Variables
                    root.style.setProperty('--button-bg', colors.accentBlue);
                    root.style.setProperty('--button-hover', colors.accentBlueHover || colors.accentBlue);
                    root.style.setProperty('--button-secondary-bg', colors.tertiary);
                    root.style.setProperty('--button-secondary-hover', colors.secondary);
                    root.style.setProperty('--input-bg', colors.tertiary);
                    root.style.setProperty('--terminal-bg', colors.terminalBg || colors.primary);
                    
                    // Interactive States
                    root.style.setProperty('--sidebar-item-hover-bg', colors.secondary);
                    root.style.setProperty('--sidebar-item-selected-bg', colors.accentBlue);
                    root.style.setProperty('--sidebar-item-bg', colors.secondary);
                    
                    // Enhanced Variables for Comprehensive Theming
                    root.style.setProperty('--scrollbar-slider', colors.textMuted + '66');
                    root.style.setProperty('--scrollbar-slider-hover', colors.textSecondary + 'b3');
                    root.style.setProperty('--modal-backdrop', 'rgba(0, 0, 0, 0.6)');
                },

                async loadTheme() {
                    try {
                        const response = await fetch('/api/theme', {
                            headers: {
                                'Authorization': `Bearer ${localStorage.getItem('authToken')}`
                            }
                        });
                        if (response.ok) {
                            const data = await response.json();
                            if (data.success && data.theme) {
                                this.currentTheme = data.theme;
                                this.applyTheme(data.theme);
                            }
                        }
                    } catch (error) {
                        console.error('Failed to load theme:', error);
                    }
                },

                async saveTheme(theme) {
                    try {
                        await fetch('/api/theme', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${localStorage.getItem('authToken')}`
                            },
                            body: JSON.stringify({ theme })
                        });
                    } catch (error) {
                        console.error('Failed to save theme:', error);
                    }
                },

                async initializeApp() {
                    try {
                        this.initializeSocket();
                    } catch (error) {
                        console.error('Failed to initialize app:', error);
                        this.logout();
                    }
                },
                
                initializeSocket() {
                    // Socket connection options with retry configuration
                    const socketOptions = {
                        auth: { token: localStorage.getItem('authToken') },
                        reconnection: true,
                        reconnectionDelay: 1000,
                        reconnectionDelayMax: 5000,
                        reconnectionAttempts: Infinity,
                        timeout: 20000
                    };
                    
                    this.socket = io('/', socketOptions);
                    
                    this.socket.on('connect', () => {
                        console.log('Socket connected');
                        this.connectionError = null;
                        
                        // Re-initialize application state
                        this.loadWorkspaces();
                        this.loadStats();
                        this.startStatsInterval();
                        this.loadTheme();
                        if (this.availableThemes.length === 0) {
                            this.loadAvailableThemes();
                        }
                        
                        // Re-select workspace if one was selected
                        if (this.selectedWorkspace) {
                            this.$nextTick(() => {
                                this.setupTerminal();
                            });
                        }
                    });
                    
                    this.socket.on('connect_error', (error) => {
                        console.error('Socket connection error:', error);
                        this.connectionError = 'Connection lost. Reconnecting...';
                        
                        if (error.message.includes('GitHub token not found') || 
                            error.message.includes('Authentication failed')) {
                            this.logout();
                        }
                    });
                    
                    this.socket.on('disconnect', (reason) => {
                        console.log('Socket disconnected:', reason);
                        this.connectionError = 'Connection lost. Reconnecting...';
                        this.stopStatsInterval();
                        
                        if (reason === 'io server disconnect') {
                            // Server disconnected us, try to reconnect
                            this.socket.connect();
                        }
                    });
                    
                    this.socket.on('reconnect', (attemptNumber) => {
                        console.log('Socket reconnected after', attemptNumber, 'attempts');
                        this.connectionError = null;
                    });
                    
                    this.socket.on('reconnect_attempt', (attemptNumber) => {
                        console.log('Socket reconnection attempt:', attemptNumber);
                        this.connectionError = `Reconnecting... (attempt ${attemptNumber})`;
                    });
                    
                    this.socket.on('reconnect_error', (error) => {
                        console.error('Socket reconnection error:', error);
                        this.connectionError = 'Reconnection failed. Retrying...';
                    });
                    
                    this.socket.on('reconnect_failed', () => {
                        console.error('Socket reconnection failed permanently');
                        this.connectionError = 'Connection failed. Please refresh the page.';
                    });
                    
                    // Terminal event handlers
                    this.socket.on('terminal-output', (data) => {
                        if (this.terminal) {
                            this.terminal.write(data);
                        }
                    });
                    
                    this.socket.on('terminal-error', (data) => {
                        console.error('Terminal error:', data.error);
                    });
                    
                    this.socket.on('terminal-resumed', (data) => {
                        console.log('Session resumed:', data);
                        // You could add a toast notification here
                    });
                    
                    // Workspace event handlers
                    this.socket.on('workspaces-list', (data) => {
                        this.workspaces = data.workspaces || [];
                    });
                    
                    // Repository event handlers
                    this.socket.on('repositories-list', (data) => {
                        const newRepos = data.repositories || [];
                        const pagination = data.pagination || {};
                        
                        if (pagination.page === 1 || pagination.search_applied) {
                            // First page, refresh, or new search - replace all repositories
                            this.repositories = newRepos;
                        } else {
                            // Subsequent pages - append to existing repositories
                            this.repositories = [...this.repositories, ...newRepos];
                        }
                        
                        // Trust the backend Link header pagination
                        this.repositoryPage = pagination.page || 1;
                        this.repositoryHasMore = pagination.has_more || false;
                        this.repositoriesLoading = false;
                        this.repositoryLoadingMore = false;
                        this.repositoryError = null;
                    });
                    
                    this.socket.on('repositories-error', (data) => {
                        this.repositoryError = data.error;
                        this.repositoriesLoading = false;
                        this.repositoryLoadingMore = false;
                    });
                    
                    // Handle authentication required - auto-redirect to GitHub OAuth
                    this.socket.on('auth-required', (data) => {
                        console.log('🔑 AUTH-REQUIRED EVENT RECEIVED:', data);
                        console.log('📊 Event data:', JSON.stringify(data, null, 2));
                        this.repositoriesLoading = false;
                        this.repositoryLoadingMore = false;
                        
                        // Auto-redirect to GitHub OAuth for re-authentication
                        if (data.action === 'redirect_to_auth') {
                            console.log('🔄 Initiating auto-redirect to GitHub OAuth...');
                            // Show brief message before redirect
                            this.repositoryError = 'Redirecting to GitHub for re-authentication...';
                            
                            // Redirect to GitHub auth after short delay
                            setTimeout(() => {
                                console.log('🚀 Redirecting to /api/github/auth');
                                window.location.href = '/api/github/auth';
                            }, 1500);
                        }
                    });
                    
                    // Workspace operation event handlers
                    this.socket.on('workspace-progress', (data) => {
                        console.log('Received workspace-progress:', data);
                        this.cloneProgress = data;
                    });

                    this.socket.on('workspace-created', (data) => {
                        console.log('Received workspace-created:', data);
                        this.cloneProgress = { 
                            status: 'created', 
                            message: 'Workspace created, starting clone...' 
                        };
                    });

                    this.socket.on('workspace-cloned', (data) => {
                        console.log('Received workspace-cloned:', data);
                        this.clearCloneState();
                        this.loadWorkspaces();
                        this.showRepositoriesModal = false;
                    });
                    
                    this.socket.on('workspace-error', (data) => {
                        console.log('Received workspace-error:', data);
                        this.cloneError = data.error;
                        this.cloneProgress = null;
                        this.cloningRepository = null;
                    });
                    
                    this.socket.on('workspace-deleted', (data) => {
                        this.deletingWorkspace = false;
                        this.showDeleteModal = false;
                        this.workspaceToDelete = null;
                        this.deleteFiles = false;
                        
                        // If deleted workspace was selected, clear selection
                        if (this.selectedWorkspace?.id === data.workspaceId) {
                            this.selectedWorkspace = null;
                            // Clear terminal
                            const terminalElement = document.getElementById('terminal');
                            if (terminalElement) {
                                terminalElement.innerHTML = '<div class="no-workspace">Select a workspace to start terminal session</div>';
                            }
                        }
                    });
                },
                
                loadWorkspaces() {
                    // Workspaces are loaded automatically on connect
                },

                async loadStats() {
                    try {
                        const response = await fetch('/api/stats', {
                            headers: {
                                'Authorization': `Bearer ${localStorage.getItem('authToken')}`
                            }
                        });
                        if (response.ok) {
                            this.stats = await response.json();
                        }
                    } catch (error) {
                        console.error('Failed to load stats:', error);
                    }
                },

                startStatsInterval() {
                    this.statsInterval = setInterval(() => {
                        this.loadStats();
                    }, 5000); // Update every 5 seconds
                },

                stopStatsInterval() {
                    if (this.statsInterval) {
                        clearInterval(this.statsInterval);
                        this.statsInterval = null;
                    }
                },
                
                selectWorkspace(workspace) {
                    // Check if we're actually switching to a different workspace
                    if (this.selectedWorkspace && this.selectedWorkspace.id === workspace.id) {
                        return; // No change needed
                    }
                    
                    this.selectedWorkspace = workspace;
                    if (this.isMobile) {
                        this.sidebarOpen = false;
                    }
                    
                    // Reset file explorer state for new workspace
                    this.currentPath = '.';
                    this.currentFiles = [];
                    this.selectedFile = null;
                    this.fileError = null;
                    this.directoryCache.clear(); // Clear cache for new workspace
                    this.clearFileSearch(); // Clear any active search
                    this.selectedFileIndex = -1; // Reset keyboard selection
                    
                    this.$nextTick(() => {
                        this.setupTerminal();
                        // Load files for the selected workspace
                        this.refreshFiles();
                    });
                },
                
                setupTerminal() {
                    // Clear the terminal display area first
                    const terminalElement = document.getElementById('terminal');
                    
                    // Safely dispose of existing terminal
                    if (this.terminal) {
                        try {
                            this.terminal.dispose();
                        } catch (error) {
                            // Silently handle addon disposal errors - they're expected during switching
                            if (!error.message?.includes('Could not dispose an addon')) {
                                console.warn('Unexpected terminal disposal error:', error);
                            }
                        }
                        this.terminal = null;
                    }
                    
                    // Cleanup previous resize handlers
                    if (this.cleanupResize) {
                        this.cleanupResize();
                        this.cleanupResize = null;
                    }
                    
                    // Clear addon references
                    this.fitAddon = null;
                    
                    // Clear the terminal element content
                    if (terminalElement) {
                        terminalElement.innerHTML = '';
                    }
                    
                    // Initialize xterm.js with current theme
                    this.terminal = new Terminal({
                        cursorBlink: true,
                        theme: this.currentTheme.terminal,
                        fontFamily: '"Cascadia Code", "Fira Code", "Monaco", "Menlo", "Ubuntu Mono", monospace',
                        fontSize: 13,
                        lineHeight: 1.2
                    });
                    
                    this.fitAddon = new FitAddon.FitAddon();
                    this.terminal.loadAddon(this.fitAddon);
                    
                    this.terminal.open(terminalElement);
                    
                    // Fit terminal to container (extra delay for mobile)
                    const delay = this.isMobile ? 200 : 100;
                    setTimeout(() => {
                        this.fitAddon.fit();
                    }, delay);
                    
                    // Handle user input
                    this.terminal.onData(data => {
                        if (this.socket) {
                            this.socket.emit('terminal-input', data);
                        }
                    });
                    
                    // Handle terminal resize
                    this.terminal.onResize(({ cols, rows }) => {
                        if (this.socket) {
                            this.socket.emit('terminal-resize', { cols, rows });
                        }
                    });
                    
                    // Create terminal session for the selected workspace
                    if (this.socket && this.selectedWorkspace) {
                        this.socket.emit('create-terminal', { 
                            workspaceId: this.selectedWorkspace.id 
                        });
                    }
                    
                    // Handle window resize with proper debouncing (remove previous listener first to avoid duplicates)
                    window.removeEventListener('resize', this.handleWindowResize);
                    this.cleanupResize && this.cleanupResize();
                    
                    let resizeTimeout;
                    this.handleWindowResize = () => {
                        clearTimeout(resizeTimeout);
                        resizeTimeout = setTimeout(() => {
                            try {
                                if (this.fitAddon && this.terminal) {
                                    this.fitAddon.fit();
                                    if (this.socket?.connected) {
                                        this.socket.emit('terminal-resize', {
                                            cols: this.terminal.cols,
                                            rows: this.terminal.rows
                                        });
                                    }
                                }
                            } catch (err) {
                                console.warn('Terminal resize failed:', err);
                            }
                        }, 100); // Debounce resize events
                    };
                    
                    // Store cleanup function
                    this.cleanupResize = () => {
                        clearTimeout(resizeTimeout);
                        window.removeEventListener('resize', this.handleWindowResize);
                    };
                    
                    window.addEventListener('resize', this.handleWindowResize);
                },
                
                async loadRepositories(reset = true) {
                    if (reset) {
                        this.repositoriesLoading = true;
                        this.repositoryError = null;
                        this.repositories = [];
                        this.repositoryPage = 1;
                        this.repositoryHasMore = true;
                    } else {
                        // Loading more
                        if (this.repositoryLoadingMore || !this.repositoryHasMore) {
                            return;
                        }
                        this.repositoryLoadingMore = true;
                    }
                    
                    if (this.socket) {
                        this.socket.emit('get-repositories', { 
                            page: reset ? 1 : this.repositoryPage + 1,
                            per_page: 100,
                            search: this.repositorySearchTerm || ''
                        });
                    }
                },
                
                loadMoreRepositories() {
                    if (!this.repositoryHasMore || this.repositoryLoadingMore) {
                        return;
                    }
                    this.loadRepositories(false);
                },

                handleRepositorySearch() {
                    // Debounce search input to avoid too many requests
                    if (this.searchTimeout) {
                        clearTimeout(this.searchTimeout);
                    }
                    
                    this.searchTimeout = setTimeout(() => {
                        // Reset pagination for new search
                        this.repositoryPage = 1;
                        this.repositoryHasMore = true;
                        this.loadRepositories(true);
                    }, 300);
                },

                clearRepositorySearch() {
                    this.repositorySearchTerm = '';
                    if (this.searchTimeout) {
                        clearTimeout(this.searchTimeout);
                    }
                    // Reset pagination and reload repositories
                    this.repositoryPage = 1;
                    this.repositoryHasMore = true;
                    this.loadRepositories(true);
                },
                
                async cloneRepository(repo) {
                    console.log('Starting clone for repo:', repo);
                    if (this.socket) {
                        // Set loading state
                        this.cloningRepository = repo;
                        this.cloneProgress = { 
                            status: 'starting', 
                            message: `Starting clone of ${repo.name}...` 
                        };
                        this.cloneError = null;

                        console.log('Emitting create-workspace event');
                        this.socket.emit('create-workspace', {
                            githubRepo: repo.full_name,
                            githubUrl: repo.clone_url
                        });
                    }
                },

                clearCloneState() {
                    console.log('Clearing clone state');
                    this.cloningRepository = null;
                    this.cloneProgress = null;
                    this.cloneError = null;
                },

                dismissCloneError() {
                    this.clearCloneState();
                },

                formatDate(dateString) {
                    const date = new Date(dateString);
                    const now = new Date();
                    const diffInHours = Math.floor((now - date) / (1000 * 60 * 60));

                    if (diffInHours < 24) {
                        return `${diffInHours}h ago`;
                    } else {
                        const diffInDays = Math.floor(diffInHours / 24);
                        return `${diffInDays}d ago`;
                    }
                },

                getLanguageColor(language) {
                    const colors = {
                        JavaScript: '#f1e05a',
                        TypeScript: '#3178c6',
                        Python: '#3572A5',
                        Java: '#b07219',
                        'C++': '#f34b7d',
                        C: '#555555',
                        'C#': '#239120',
                        PHP: '#4F5D95',
                        Ruby: '#701516',
                        Go: '#00ADD8',
                        Rust: '#dea584',
                        Swift: '#fa7343',
                        Kotlin: '#A97BFF',
                        Dart: '#00B4AB',
                        HTML: '#e34c26',
                        CSS: '#1572B6',
                        Vue: '#4FC08D',
                        React: '#61DAFB',
                        Angular: '#DD0031',
                        Shell: '#89e051',
                        PowerShell: '#012456',
                        Dockerfile: '#384d54',
                        YAML: '#cb171e'
                    };
                    return colors[language] || '#8b949e';
                },

                formatStars(count) {
                    if (count >= 1000) {
                        return (count / 1000).toFixed(1) + 'k';
                    }
                    return count.toString();
                },
                
                confirmDeleteWorkspace(workspace) {
                    this.workspaceToDelete = workspace;
                    this.deleteFiles = false;
                    this.showDeleteModal = true;
                },
                
                deleteWorkspace() {
                    if (!this.workspaceToDelete) return;
                    
                    this.deletingWorkspace = true;
                    
                    if (this.socket) {
                        this.socket.emit('delete-workspace', {
                            workspaceId: this.workspaceToDelete.id,
                            deleteFiles: this.deleteFiles
                        });
                    }
                },

                // File Explorer Methods
                async refreshFiles(forceRefresh = false) {
                    if (!this.selectedWorkspace) return;
                    
                    const cacheKey = `${this.selectedWorkspace.id}:${this.currentPath}:${this.showHiddenFiles}`;
                    
                    // Check cache first (unless forced refresh)
                    if (!forceRefresh && this.directoryCache.has(cacheKey)) {
                        const cached = this.directoryCache.get(cacheKey);
                        const now = Date.now();
                        
                        if (now - cached.timestamp < this.cacheTimeout) {
                            this.currentFiles = cached.contents;
                            this.currentPath = cached.path;
                            return;
                        } else {
                            // Remove expired cache entry
                            this.directoryCache.delete(cacheKey);
                        }
                    }
                    
                    this.loadingFiles = true;
                    this.fileError = null;
                    
                    try {
                        const token = localStorage.getItem('authToken');
                        const response = await fetch(`/api/workspaces/${this.selectedWorkspace.id}/files?path=${encodeURIComponent(this.currentPath)}`, {
                            headers: {
                                'Authorization': `Bearer ${token}`
                            }
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            this.currentFiles = data.contents || [];
                            this.currentPath = data.path || '.';
                            
                            // Cache the results
                            this.directoryCache.set(cacheKey, {
                                contents: data.contents || [],
                                path: data.path || '.',
                                timestamp: Date.now()
                            });
                        } else {
                            const errorData = await response.json();
                            this.fileError = errorData.error || 'Failed to load files';
                        }
                    } catch (error) {
                        this.fileError = 'Failed to connect to server';
                        console.error('Error loading files:', error);
                    } finally {
                        this.loadingFiles = false;
                    }
                },

                toggleFileExplorer() {
                    this.fileExplorerCollapsed = !this.fileExplorerCollapsed;
                },

                handleFileClick(file, index = -1) {
                    this.selectedFile = file;
                    this.selectedFileIndex = index;
                },

                handleFileDoubleClick(file) {
                    if (file.type === 'directory') {
                        // Navigate to directory
                        this.currentPath = file.path === '.' ? file.name : file.path;
                        this.selectedFileIndex = -1; // Reset keyboard selection
                        this.refreshFiles();
                    } else {
                        // For files, show preview or run cat command
                        this.showFilePreview(file);
                    }
                },

                navigateToParent() {
                    if (this.currentPath === '.') return;
                    
                    const pathParts = this.currentPath.split('/');
                    pathParts.pop();
                    this.currentPath = pathParts.length > 0 ? pathParts.join('/') : '.';
                    this.selectedFileIndex = -1; // Reset keyboard selection
                    this.refreshFiles();
                },

                navigateToRoot() {
                    this.currentPath = '.';
                    this.selectedFileIndex = -1; // Reset keyboard selection
                    this.refreshFiles();
                },

                navigateToSegment(index) {
                    const segments = this.pathSegments.slice(0, index + 1);
                    this.currentPath = segments.length > 0 ? segments.join('/') : '.';
                    this.selectedFileIndex = -1; // Reset keyboard selection
                    this.refreshFiles();
                },

                async showFilePreview(file) {
                    if (!this.selectedWorkspace) return;
                    
                    // Set modal state
                    this.previewFile = file;
                    this.previewData = null;
                    this.previewError = null;
                    this.previewLoading = true;
                    this.showFilePreviewModal = true;
                    
                    try {
                        const token = localStorage.getItem('authToken');
                        const response = await fetch(`/api/workspaces/${this.selectedWorkspace.id}/file-content?path=${encodeURIComponent(file.path)}`, {
                            headers: {
                                'Authorization': `Bearer ${token}`
                            }
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            this.previewData = data;
                        } else {
                            const errorData = await response.json();
                            this.previewError = errorData.error || 'Failed to load file content';
                        }
                    } catch (error) {
                        console.error('Error previewing file:', error);
                        this.previewError = 'Failed to connect to server';
                    } finally {
                        this.previewLoading = false;
                    }
                },

                runCatCommand(filePath) {
                    if (this.socket && this.terminal) {
                        const command = `cat "${filePath}"\r`;
                        this.socket.emit('shell-input', { data: command });
                        
                        // Focus on terminal
                        this.terminal.focus();
                    }
                },

                async refreshFilePreview() {
                    if (!this.previewFile) return;
                    await this.showFilePreview(this.previewFile);
                },

                getFileIcon(file) {
                    if (file.type === 'directory') {
                        return 'folder';
                    }
                    
                    // Basic file type icons
                    const ext = file.extension?.toLowerCase();
                    switch (ext) {
                        case 'js': case 'jsx': case 'ts': case 'tsx':
                            return 'file-text';
                        case 'json':
                            return 'code';
                        case 'md': case 'txt':
                            return 'file-text';
                        case 'html': case 'css': case 'scss': case 'sass':
                            return 'code';
                        case 'py':
                            return 'file-text';
                        case 'jpg': case 'jpeg': case 'png': case 'gif': case 'svg':
                            return 'image';
                        case 'pdf':
                            return 'file-text';
                        case 'zip': case 'tar': case 'gz':
                            return 'archive';
                        default:
                            return 'file';
                    }
                },

                formatFileSize(bytes) {
                    if (bytes === 0) return '0 B';
                    const k = 1024;
                    const sizes = ['B', 'KB', 'MB', 'GB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
                },

                getPrismLanguage(file) {
                    if (!file || !file.extension) return null;
                    
                    const ext = file.extension.toLowerCase();
                    const languageMap = {
                        'js': 'javascript',
                        'jsx': 'jsx',
                        'ts': 'typescript',
                        'tsx': 'tsx',
                        'json': 'json',
                        'html': 'html',
                        'htm': 'html',
                        'css': 'css',
                        'scss': 'scss',
                        'sass': 'sass',
                        'less': 'less',
                        'py': 'python',
                        'rb': 'ruby',
                        'php': 'php',
                        'java': 'java',
                        'c': 'c',
                        'cpp': 'cpp',
                        'cc': 'cpp',
                        'cxx': 'cpp',
                        'h': 'c',
                        'hpp': 'cpp',
                        'cs': 'csharp',
                        'go': 'go',
                        'rs': 'rust',
                        'sh': 'bash',
                        'bash': 'bash',
                        'zsh': 'bash',
                        'fish': 'bash',
                        'ps1': 'powershell',
                        'sql': 'sql',
                        'xml': 'xml',
                        'yaml': 'yaml',
                        'yml': 'yaml',
                        'toml': 'toml',
                        'ini': 'ini',
                        'conf': 'ini',
                        'config': 'ini',
                        'md': 'markdown',
                        'markdown': 'markdown',
                        'tex': 'latex',
                        'r': 'r',
                        'matlab': 'matlab',
                        'm': 'matlab',
                        'swift': 'swift',
                        'kt': 'kotlin',
                        'scala': 'scala',
                        'clj': 'clojure',
                        'hs': 'haskell',
                        'elm': 'elm',
                        'dart': 'dart',
                        'lua': 'lua',
                        'perl': 'perl',
                        'pl': 'perl',
                        'dockerfile': 'dockerfile',
                        'makefile': 'makefile',
                        'cmake': 'cmake',
                        'gradle': 'gradle',
                        'groovy': 'groovy',
                        'vim': 'vim',
                        'asm': 'nasm',
                        's': 'nasm'
                    };
                    
                    return languageMap[ext] || null;
                },

                getLanguageClass(file) {
                    const language = this.getPrismLanguage(file);
                    return language ? `language-${language}` : '';
                },

                escapeHtml(text) {
                    const div = document.createElement('div');
                    div.textContent = text;
                    return div.innerHTML;
                },

                handleFileContextMenu(event, file) {
                    event.preventDefault();
                    this.contextMenuFile = file;
                    this.contextMenuX = event.clientX;
                    this.contextMenuY = event.clientY;
                    this.showContextMenu = true;

                    // Close context menu when clicking elsewhere
                    const closeContextMenu = (e) => {
                        if (!e.target.closest('.context-menu')) {
                            this.showContextMenu = false;
                            document.removeEventListener('click', closeContextMenu);
                        }
                    };
                    
                    this.$nextTick(() => {
                        document.addEventListener('click', closeContextMenu);
                    });
                },

                copyFilePath() {
                    if (!this.contextMenuFile) return;
                    
                    const fullPath = this.contextMenuFile.path;
                    this.copyToClipboard(fullPath);
                    this.showContextMenu = false;
                },

                copyFileName() {
                    if (!this.contextMenuFile) return;
                    
                    this.copyToClipboard(this.contextMenuFile.name);
                    this.showContextMenu = false;
                },

                previewFile() {
                    if (!this.contextMenuFile) return;
                    
                    this.showFilePreview(this.contextMenuFile);
                    this.showContextMenu = false;
                },

                openInTerminal() {
                    if (!this.contextMenuFile) return;
                    
                    this.runCatCommand(this.contextMenuFile.path);
                    this.showContextMenu = false;
                },

                openDirectory() {
                    if (!this.contextMenuFile) return;
                    
                    this.handleFileDoubleClick(this.contextMenuFile);
                    this.showContextMenu = false;
                },

                copyToClipboard(text) {
                    if (navigator.clipboard && window.isSecureContext) {
                        navigator.clipboard.writeText(text).then(() => {
                            this.showNotification('Copied to clipboard', 'success');
                        }).catch(() => {
                            this.fallbackCopyToClipboard(text);
                        });
                    } else {
                        this.fallbackCopyToClipboard(text);
                    }
                },

                fallbackCopyToClipboard(text) {
                    const textArea = document.createElement('textarea');
                    textArea.value = text;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-999999px';
                    textArea.style.top = '-999999px';
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    
                    try {
                        document.execCommand('copy');
                        this.showNotification('Copied to clipboard', 'success');
                    } catch (err) {
                        console.error('Failed to copy text: ', err);
                        this.showNotification('Failed to copy to clipboard', 'error');
                    } finally {
                        document.body.removeChild(textArea);
                    }
                },

                showNotification(message, type = 'info') {
                    // Simple notification - could be enhanced with a proper toast system
                    console.log(`[${type.toUpperCase()}] ${message}`);
                    
                    // Create a simple toast notification
                    const toast = document.createElement('div');
                    toast.className = `toast toast-${type}`;
                    toast.textContent = message;
                    toast.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: var(--accent-green);
                        color: white;
                        padding: 12px 16px;
                        border-radius: 6px;
                        z-index: 10000;
                        font-size: 13px;
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                        animation: slideInRight 0.3s ease-out;
                    `;
                    
                    if (type === 'error') {
                        toast.style.background = 'var(--accent-red)';
                    } else if (type === 'warning') {
                        toast.style.background = 'var(--accent-orange)';
                    }
                    
                    document.body.appendChild(toast);
                    
                    setTimeout(() => {
                        toast.style.animation = 'slideOutRight 0.3s ease-in';
                        setTimeout(() => {
                            if (document.body.contains(toast)) {
                                document.body.removeChild(toast);
                            }
                        }, 300);
                    }, 3000);
                },

                isTerminalFocused() {
                    // Check if the terminal has focus
                    const activeElement = document.activeElement;
                    
                    // Check if the active element is the terminal or within the terminal container
                    if (activeElement && (
                        activeElement.classList?.contains('xterm-helper-textarea') ||
                        activeElement.closest('.terminal-container') ||
                        activeElement.closest('.xterm') ||
                        activeElement.closest('.xterm-screen')
                    )) {
                        return true;
                    }
                    
                    // Also check if the terminal object exists and has focus
                    if (this.terminal && this.terminal.textarea) {
                        return document.activeElement === this.terminal.textarea;
                    }
                    
                    return false;
                },

                handleFileSearch() {
                    // Debounce search input
                    if (this.fileSearchTimeout) {
                        clearTimeout(this.fileSearchTimeout);
                    }
                    
                    this.fileSearchTimeout = setTimeout(() => {
                        // Search is handled by computed property filteredFiles
                        // This timeout just prevents excessive reactivity updates
                    }, 150);
                },

                clearFileSearch() {
                    this.fileSearchTerm = '';
                    this.selectedFileIndex = -1; // Reset keyboard selection
                    if (this.fileSearchTimeout) {
                        clearTimeout(this.fileSearchTimeout);
                        this.fileSearchTimeout = null;
                    }
                },

                handleFileNavigationKeys(e) {
                    const files = this.filteredFiles;
                    if (files.length === 0) return;

                    switch (e.key) {
                        case 'ArrowDown':
                            e.preventDefault();
                            this.selectedFileIndex = Math.min(this.selectedFileIndex + 1, files.length - 1);
                            this.scrollToSelectedFile();
                            break;
                        case 'ArrowUp':
                            e.preventDefault();
                            this.selectedFileIndex = Math.max(this.selectedFileIndex - 1, -1);
                            this.scrollToSelectedFile();
                            break;
                        case 'Enter':
                            e.preventDefault();
                            if (this.selectedFileIndex >= 0 && this.selectedFileIndex < files.length) {
                                const selectedFile = files[this.selectedFileIndex];
                                this.handleFileDoubleClick(selectedFile);
                            }
                            break;
                        case ' ': // Space
                            e.preventDefault();
                            if (this.selectedFileIndex >= 0 && this.selectedFileIndex < files.length) {
                                const selectedFile = files[this.selectedFileIndex];
                                this.handleFileClick(selectedFile, this.selectedFileIndex);
                            }
                            break;
                        case '/':
                            e.preventDefault();
                            // Focus on search input
                            this.$nextTick(() => {
                                const searchInput = document.querySelector('.file-search-input');
                                if (searchInput) {
                                    searchInput.focus();
                                }
                            });
                            break;
                    }
                },

                scrollToSelectedFile() {
                    if (this.selectedFileIndex < 0) return;
                    
                    this.$nextTick(() => {
                        const fileItems = document.querySelectorAll('.file-item');
                        const selectedElement = fileItems[this.selectedFileIndex + (this.currentPath !== '.' ? 1 : 0)]; // +1 for parent nav
                        
                        if (selectedElement) {
                            selectedElement.scrollIntoView({
                                behavior: 'smooth',
                                block: 'nearest'
                            });
                        }
                    });
                },
                
                handleRepositoryScroll(event) {
                    const element = event.target;
                    const threshold = 100; // px from bottom
                    
                    if (element.scrollTop + element.clientHeight >= element.scrollHeight - threshold) {
                        // Debounce scroll events to prevent rapid-fire requests
                        if (this.scrollTimeout) {
                            clearTimeout(this.scrollTimeout);
                        }
                        this.scrollTimeout = setTimeout(() => {
                            this.loadMoreRepositories();
                        }, 100);
                    }
                },
                
                async logout() {
                    // Add confirmation dialog for safety
                    if (!confirm('Are you sure you want to logout?')) {
                        return;
                    }
                    
                    console.log('Logging out...');
                    try {
                        // Step 1: Tell the server to revoke tokens (best-effort)
                        await fetch('/api/auth/logout', {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${localStorage.getItem('authToken')}`
                            }
                        });
                    } catch (error) {
                        console.error('Server logout call failed, proceeding with client-side logout:', error);
                    } finally {
                        // Step 2: Always clear client-side state and reload
                        this.stopStatsInterval();
                        localStorage.removeItem('authToken');
                        if (this.socket) {
                            this.socket.disconnect();
                        }
                        if (this.terminal) {
                            this.terminal.dispose();
                            this.terminal = null;
                        }
                        if (this.cleanupResize) {
                            this.cleanupResize();
                            this.cleanupResize = null;
                        }
                        this.isAuthenticated = false;
                        window.location.reload();
                    }
                }
            },

            updated() {
                this.$nextTick(() => {
                    feather.replace();
                });
            },
            
            watch: {
                showRepositoriesModal(newVal) {
                    if (newVal) {
                        // Reset search when modal opens
                        this.repositorySearchTerm = '';
                        if (this.searchTimeout) {
                            clearTimeout(this.searchTimeout);
                        }
                        this.loadRepositories();
                    }
                }
            },

            beforeUnmount() {
                this.stopStatsInterval();
                if (this.scrollTimeout) {
                    clearTimeout(this.scrollTimeout);
                }
                if (this.searchTimeout) {
                    clearTimeout(this.searchTimeout);
                }
                window.removeEventListener('resize', this.checkMobile);
            }
        }).mount('#app');
    </script>